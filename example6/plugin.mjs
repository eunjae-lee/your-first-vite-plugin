import { watch } from "fs";
import fs from "fs/promises";
import { relative, dirname } from "path";
import { importFromString } from "module-from-string";
import ts from "typescript";
import { createUnplugin } from "unplugin";
import pascalCase from "just-pascal-case";

const unpluginFactory = (options = {}) => {
  const generatedApiDir = options.generatedApiDir ?? "src/pages/api/gen";
  const serverlessFunctionDir =
    options.serverlessFunctionDir ?? "src/serverless";
  const hooksPath = options.hooksDir ?? "src/hooks/api.ts";

  return {
    name: "UnpluginStarter",
    async buildStart() {
      watch(`./${serverlessFunctionDir}/`, (_event, filename) => {
        this.addWatchFile(`${serverlessFunctionDir}/${filename}`);
      });

      const files = await fs.readdir(serverlessFunctionDir);
      for (const file of files) {
        await generateEndpoint({
          path: `./${serverlessFunctionDir}/${file}`,
          generatedApiDir,
          serverlessFunctionDir,
        });
        this.addWatchFile(`${serverlessFunctionDir}/${file}`);
      }
      await generateHooks({ serverlessFunctionDir, hooksPath });
    },
    async watchChange(id) {
      if (await fs.exists(id)) {
        await generateEndpoint({
          path: id,
          generatedApiDir,
          serverlessFunctionDir,
        });
      } else {
        await removeEndpoint({ path: id, generatedApiDir });
      }
      await generateHooks({ serverlessFunctionDir, hooksPath });
    },
  };
};

const generateHooks = async ({ serverlessFunctionDir, hooksPath }) => {
  await fs.mkdir(dirname(hooksPath), { recursive: true });
  const files = await fs.readdir(serverlessFunctionDir);
  const list = [];
  for (const file of files) {
    const id = file.split(".")[0];
    const mod = await importTSModule(`${serverlessFunctionDir}/${file}`);
    const method = mod.method ?? "GET";
    list.push({
      id,
      method,
    });
  }
  const relativeServerlessFunctionDir = relative(
    dirname(hooksPath),
    serverlessFunctionDir
  );
  const warning = `
// This file is auto-generated. Do not edit this file.
`;
  const imports =
    `import { z } from "zod";\n` +
    `import { useApi } from "./useApi";\n` +
    list
      .map(
        ({ id }) =>
          `import { schema as ${id}_schema } from "${relativeServerlessFunctionDir}/${id}";`
      )
      .join("\n");
  const hooks = list
    .map(
      ({ id, method }) =>
        `export function use${pascalCase(
          id
        )}(params: z.infer<typeof ${id}_schema>) {
  const parseResult = ${id}_schema.safeParse(params);
  if (!parseResult.success) {
    throw new Error("Invalid params");
  }
  return useApi({
    key: "${id}",
    method: "${method}",
    params,
  });
}`
    )
    .join("\n");

  await fs.writeFile(hooksPath, `${warning}\n\n${imports}\n\n${hooks}`);
};

const removeEndpoint = async ({ path, generatedApiDir }) => {
  const filenameWithoutExt = path.split("/").pop().split(".")[0];
  try {
    await fs.unlink(`${generatedApiDir}/${filenameWithoutExt}.ts`);
  } catch (err) {
    // ignore
  }
};

const generateEndpoint = async ({
  path,
  generatedApiDir,
  serverlessFunctionDir,
}) => {
  const filenameWithoutExt = path.split("/").pop().split(".")[0];
  const mod = await importTSModule(path);
  const method = mod.method ?? "GET";

  await fs.writeFile(
    `${generatedApiDir}/${filenameWithoutExt}.ts`,
    `
import type { NextApiRequest, NextApiResponse } from "next";
import { handler, schema } from "${relative(
      generatedApiDir,
      serverlessFunctionDir
    )}/${filenameWithoutExt}";

export default function _handler(
  req: NextApiRequest,
  res: NextApiResponse<ReturnType<typeof handler>>
) {
  if (req.method !== "${method}") {
    return res.status(405);
  }

  const result = schema.safeParse(${
    method === "GET" ? "req.query" : "JSON.parse(req.body)"
  });
  if (!result.success) {
    return res.status(400).json(result.error);
  }
  res.status(200).json(handler(result.data));
}
`
  );
};

const importTSModule = async (path) => {
  const code = await transpileTsToJs(path);
  return await importFromString(code);
};

const transpileTsToJs = async (path) => {
  const FAKE_INPUT = "fake.ts";
  const FAKE_OUTPUT = "fake.js";
  const options = {
    allowJs: true,
  };
  const code = (await fs.readFile(path, "utf-8")).toString();
  const createdFiles = {};
  const host = ts.createCompilerHost(options, true);
  host.writeFile = (fileName, contents) => {
    return (createdFiles[fileName] = contents);
  };
  const backupReadFile = host.readFile.bind(host);
  host.readFile = (fileName) => {
    if (fileName === FAKE_INPUT) {
      return code;
    } else {
      return backupReadFile(fileName);
    }
  };

  const program = ts.createProgram([FAKE_INPUT], options, host);
  program.emit();

  return createdFiles[FAKE_OUTPUT];
};

export const unplugin = createUnplugin(unpluginFactory);

export const webpackPlugin = unplugin.webpack;
